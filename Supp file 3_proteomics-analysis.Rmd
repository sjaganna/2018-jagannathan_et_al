---
title: "DUX4-proteomics"
author: "Sujatha Jagannathan"
date: "June 7, 2018"
output: html_document
---

---
title: "DUX4proteomics_figures"
author: "Sujatha Jagannathan"
date: "November 21, 2017"
output: html_document
---

###Set up
Required packages: dplyr, tidyr, stringr, ggplot2
```{r}
library(shiny)
library(tidyverse)
library(ggplot2)
library(plotly)
library(gridExtra)
set.seed(66958473)

```

###Enter data: 
Use tab-delimited PSM files from Mass spec core for each of the replicates
```{r, psmdata_input}
library(readr)
psmdata_vDUX4_24h_rep0 <- read_delim("~/Dropbox/Manuscripts/DUX4_proteomics/data/mass_spec/SJ102314_102914_05_16_TargetPeptideSpectrumMatch.txt", "\t", escape_double = FALSE, trim_ws = TRUE)

psmdata_vDUX4_36h_rep0 <- read_delim("~/Dropbox/Manuscripts/DUX4_proteomics/data/mass_spec/SJ102314_102914_17_28_TargetPeptideSpectrumMatch.txt", "\t", escape_double = FALSE, trim_ws = TRUE)

psmdata_iDUX4_14h_rep1 <- read_delim("~/Dropbox/Manuscripts/DUX4_proteomics/data/mass_spec/SJ042415_051615_31_46_TargetPeptideSpectrumMatch.txt", "\t", escape_double = FALSE, trim_ws = TRUE)

psmdata_iDUX4_14h_rep2 <- read_delim("~/Dropbox/Manuscripts/DUX4_proteomics/data/mass_spec/SJ090815_091515_47_62_TargetPeptideSpectrumMatch.txt", "\t", escape_double = FALSE, trim_ws = TRUE)

psmdata_iDUX4_14h_rep1 <- dplyr::tbl_df(psmdata_iDUX4_14h_rep1)
psmdata_iDUX4_14h_rep2 <- dplyr::tbl_df(psmdata_iDUX4_14h_rep2)
psmdata_vDUX4_24h_rep0 <- dplyr::tbl_df(psmdata_vDUX4_24h_rep0)
psmdata_vDUX4_36h_rep0 <- dplyr::tbl_df(psmdata_vDUX4_36h_rep0)
```


1.Giving meaningful names to the columns to enable subsetting as follows: 
```{r}
colnames.vDUX4 = c("Annotated Sequence"="peptide.sequence", "Modifications"="modifications", "Master Protein Accessions"="masterids", "Protein Accessions"="ids", "# Protein Groups"="num.masterids", "# Proteins"="num.ids", "# Missing Channels"="missing.channel", "# Single-Peak Channels"="single.peak", "Percolator q-Value"="q.value", "Percolator PEP"="pep.value", "Quan Info"="quan.info", "Peptide Quan Usage"="quan.usage", "Precursor Quan Result ID"="quan.id", "Spectrum File"="band.id", "Area"="area", "Light"="ctrl", "Heavy"="dux4")

colnames.iDUX4.rep1 = c("Annotated Sequence"="peptide.sequence", "Modifications"="modifications", "Master Protein Accessions"="masterids", "Protein Accessions"="ids", "# Protein Groups"="num.masterids", "# Proteins"="num.ids", "# Missing Channels"="missing.channel", "# Single-Peak Channels"="single.peak", "Percolator q-Value"="q.value", "Percolator PEP"="pep.value", "Quan Info"="quan.info", "Peptide Quan Usage"="quan.usage", "Precursor Quan Result ID"="quan.id", "Spectrum File"="band.id", "Area"="area", "Light"="ctrl", "Heavy"="dux4")

#label swap replicate
colnames.iDUX4.rep2 = c("Annotated Sequence"="peptide.sequence", "Modifications"="modifications", "Master Protein Accessions"="masterids", "Protein Accessions"="ids", "# Protein Groups"="num.masterids", "# Proteins"="num.ids", "# Missing Channels"="missing.channel", "# Single-Peak Channels"="single.peak", "Percolator q-Value"="q.value", "Percolator PEP"="pep.value", "Quan Info"="quan.info", "Peptide Quan Usage"="quan.usage", "Precursor Quan Result ID"="quan.id", "Spectrum File"="band.id", "Area"="area", "Light"="dux4", "Heavy"="ctrl")

psmdata_vDUX4_24h_rep0 = psmdata_vDUX4_24h_rep0[, names(colnames.vDUX4)]
colnames(psmdata_vDUX4_24h_rep0)=colnames.vDUX4

psmdata_vDUX4_36h_rep0 = psmdata_vDUX4_36h_rep0[, names(colnames.vDUX4)]
colnames(psmdata_vDUX4_36h_rep0)=colnames.vDUX4

psmdata_iDUX4_14h_rep1 = psmdata_iDUX4_14h_rep1[, names(colnames.iDUX4.rep1)]
colnames(psmdata_iDUX4_14h_rep1)=colnames.iDUX4.rep1

psmdata_iDUX4_14h_rep2 = psmdata_iDUX4_14h_rep2[, names(colnames.iDUX4.rep2)]
colnames(psmdata_iDUX4_14h_rep2)=colnames.iDUX4.rep2

library(knitr)
kable(cbind(psms_iDUX4_rep1 = nrow(psmdata_iDUX4_14h_rep1), 
            psms_iDUX4_rep2 = nrow(psmdata_iDUX4_14h_rep2), 
            psms_vDUX4_24h = nrow(psmdata_vDUX4_24h_rep0), 
            psms_vDUX4_36h = nrow(psmdata_vDUX4_36h_rep0)))

```  


2. Merge the two reps after assigning "rep" id
```{r}
psmdata_vDUX4_24h_rep0 <- psmdata_vDUX4_24h_rep0 %>% mutate(rep = "1")
psmdata_vDUX4_36h_rep0 <- psmdata_vDUX4_36h_rep0 %>% mutate(rep = "2")
psmdata_iDUX4_14h_rep1 <- psmdata_iDUX4_14h_rep1 %>% mutate(rep = "3")
psmdata_iDUX4_14h_rep2 <- psmdata_iDUX4_14h_rep2 %>% mutate(rep = "4")
psmdata.static <- rbind(psmdata_vDUX4_24h_rep0, psmdata_vDUX4_36h_rep0, psmdata_iDUX4_14h_rep1, psmdata_iDUX4_14h_rep2)
```  


3. assigning peptide ids as row names for each of the `r nrow(psmdata.static)` rows  
```{r}
row.names = paste0("peptide", c(1:nrow(psmdata.static)))
rownames(psmdata.static)=row.names
```  


4. filter psmdata to remove all but unique peptides and exlcudedbymethod peptides (which includes missing.channel psms in the case of replicate 1):  
```{r}
library(knitr)
kable(cbind(psms = table(psmdata.static$quan.info))) 
psmdata.static.filtered <- psmdata.static[which(psmdata.static$quan.info %in% c("Unique", "ExcludedByMethod")), ]
```
Before filtering: `r kable(cbind(psms = table(psmdata.static$quan.info)))`  
After filtering: `r kable(cbind(psms = table(psmdata.static.filtered$quan.info)))`  
Of the filtered psms, there are `r table(psmdata.static.filtered$single.peak)` psms with single peaks and `r table(psmdata.static.filtered$missing.channel)` psms with missing channels.   

5. Clean up data
  a) assign single.peak and missing.channel
  b) convert peptide sequence to upper case for string matching
  c) recalculate hl.ratio to account for iDUX4_rep2 having labels swapped 
  d) filter our rows with no masterid assigned
```{r}
library("stringr")
psmdata.static.filtered <- psmdata.static.filtered %>%
  mutate(quan.info=ifelse(is.na(missing.channel), quan.info, "missing.channel")) %>%
  mutate(quan.info=ifelse(is.na(single.peak), quan.info, "single.peak")) %>% 
  mutate(peptide.sequence=str_to_upper(peptide.sequence)) %>%
  mutate(hl.ratio = dux4/ctrl) %>%
  filter(masterids != "")
```  
The resulting psmdata file has the following psms: `r kable(cbind(psms = table(psmdata.static.filtered$quan.info)))`

6. Drop the missing channel and single peak columns as that information is now in the quan.info column  
```{r}
psmdata.static.filtered <- psmdata.static.filtered[, c(1:6, 9:19)]
```  

7. Filter out single.peak and ExcludedByMethod psms  
```{r}
psmdata.static.filtered <- psmdata.static.filtered %>%
                      filter(quan.info != "single.peak") %>% 
                        filter(quan.info != "ExcludedByMethod")
```  

8. (Optional) Export 'psmdata' with `r nrow(psmdata.static.filtered)` psms as an R object  
```{r}
save(psmdata.static.filtered, file="data/rdata/psmdata.06072018.Rdata")  
```  

###Data transformation  
1. Remove psms that map to contaminants from cRAP database (all of them have the id format of 'sp')
```{r}
psmdata.static.filtered <- psmdata.static.filtered %>% filter(!grepl("; sp|^sp", ids))
```  
This step leaves us with `r nrow(psmdata.static.filtered)` psms.  

2. Replace the low missing value with 10000 to make it less fluctuating (and to not have 2 separate groups of points near the edges of the rep1 vs rep2 scatter plot) and recalculate hl.ratio and log.hl.ratio  
```{r}
psmdata.static.filtered <- psmdata.static.filtered %>% mutate(ctrl = ifelse(ctrl < 10000, 10000, ctrl)) %>% 
                      mutate(dux4 = ifelse(dux4 < 10000, 10000, dux4)) %>% 
                          mutate(hl.ratio = dux4/ctrl, log.hl.ratio = log2(dux4/ctrl))
```   

3. Normalize using means for rep1 and rep2 separately  
```{r}
tmp <- psmdata.static.filtered[-which(psmdata.static.filtered$quan.info %in% c("missing.channel")), ]
rep1 <- tmp[which(tmp$rep=="1"), ]
rep2 <- tmp[which(tmp$rep=="2"), ]
rep3 <- tmp[which(tmp$rep=="3"), ]
rep4 <- tmp[which(tmp$rep=="4"), ]

rep1.mean <- mean(rep1$log.hl.ratio)
rep2.mean <- mean(rep2$log.hl.ratio)
rep3.mean <- mean(rep3$log.hl.ratio)
rep4.mean <- mean(rep4$log.hl.ratio)
rep1.sd <- sd(rep1$log.hl.ratio)
rep2.sd <- sd(rep2$log.hl.ratio)
rep3.sd <- sd(rep3$log.hl.ratio)
rep4.sd <- sd(rep4$log.hl.ratio)

psmdata.static.norm <- psmdata.static.filtered %>% 
                  mutate(norm.hl.ratio = ifelse(rep=="1", (log.hl.ratio-rep1.mean)/rep1.sd, 
                                                ifelse(rep=="2", (log.hl.ratio-rep2.mean)/rep2.sd, 
                                                       ifelse(rep=="3", (log.hl.ratio-rep3.mean)/rep3.sd, 
                                                              (log.hl.ratio-rep4.mean)/rep4.sd))))

psmdata.static.norm <- psmdata.static.norm %>% mutate(peptide.sequence = str_replace_all(psmdata.static.norm$peptide.sequence, "[[:punct:]]", ""))
```  
`r kable(cbind(Rep1_mean = rep1.mean, Rep2_mean = rep2.mean, Rep1_sd = rep1.sd, Rep2_sd = rep2.sd))`

###Data summarization  
1. Creating a new datastructure that maps geneid -> peptide: In this step, the data structure shifts from one-peptide/many-ids to several one-peptide/one-id rows. I can then summarize these data after grouping by geneid (i. e. one-id/many-peptides). Since I am limiting myself to only unique peptides, most of my psms are one-peptide/one-id anyway. So this step is not as important as it used to be when I was not filtering out the NotUnique peptides, but I do it anyway (Note: some psms are assigned to multiple masterids, but are not listed as NotUnique and were hence not filtered out. How to handle this? GCC2 is one example)
```{r}
library("stringr")

psmdata.static.masterid <- psmdata.static.norm %>%
  # Figure out how many geneids the peptide mapped to
  mutate(nmasterids=str_count(psmdata.static.norm$masterids, pattern = ";") + 1, 
         N = row_number()) %>% 
  # Create a data frame with one geneid per row
  do(data.frame(.[rep(.$N, .$nmasterids), ], 
                masterid=unlist(strsplit(.$masterids, "; ", fixed=TRUE))))
```

2. Mapping uniprot ids to geneids and filtering out uncharacterized genes
```{r}
##Importing uniprot id -> geneid map
load("~/Dropbox/Manuscripts/DUX4_proteomics/data/rdata/uniprot.ids.sequences.Rdata")

##Joining the geneid information to psmdata dataframes and filtering uncharacterized and duplicate entries

psmdata.geneid.static <- left_join(psmdata.static.masterid, uniprot.ids.sequences, by = "masterid")
psmdata.geneid.static <- psmdata.geneid.static[, c(22:24, 19, 1:18, 25)]
psmdata.geneid.static <- filter(psmdata.geneid.static, geneid!="Uncharacterized")

```


3. printing the position of peptide in the protein (to allow peptide position mapping later)
```{r}
library("stringr")
match_position <- as.data.frame(str_locate(as.character(psmdata.geneid.static$sequences), psmdata.geneid.static$peptide.sequence))
protein.length <- str_length(as.character(psmdata.geneid.static$sequences))
psmdata.geneid.static <- cbind(psmdata.geneid.static, peptide.position = match_position$start, protein.length)
psmdata.geneid.static <- psmdata.geneid.static[, c(1:22, 24:25, 23)]
psmdata.geneid.static <- psmdata.geneid.static %>% 
                      mutate (peptide.position.index = peptide.position/protein.length)
psmdata.geneid.static <- psmdata.geneid.static[, c(1:24, 26, 25)]
```  

4. (optional) export the data
```{r}
save(psmdata.geneid.static, file="data/rdata/psmdata.geneid.static.06072018.Rdata")
```

###Bootstrapping to get significance  
1. Generate a table containing peptide.sequence, masterids and norm.hl.ratio
2. Shuffle the norm.hl.ratios randomly using sample() and do this 100 times (should I do more?)
3. Proceed to summarization of the peptide hl.ratios to get protein ratios (1000 values for each protein obtained by taking the median hl.ratio of all the peptides)- the bootstrap table will provide a distribution of protein hl.ratios derived from randomly assigned peptide ratios. Hence, the mean and standard deviation will depend on how many peptides were summarized into the protein hl.ratio. Fewer peptides would mean more noise. From this table, I can calculate the mean and sd of protein hl.ratios expected under the null hypothesis and use this to derive a p.value for the actual observed ratio. 
```{r}
psmdata.static.norm.bootstrap <- psmdata.static.norm %>% filter(rep != "1", rep!= "2")
bootstrap <- data.frame(cbind(psmdata.static.norm.bootstrap[, c(1, 3, 19)], replicate(1000, {sample(psmdata.static.norm.bootstrap$norm.hl.ratio)})))

#bootstrap data
bootstrap.masterid <- bootstrap %>% 
   # Figure out how many geneids the peptide mapped to
  mutate(nmasterids=str_count(bootstrap$masterids, pattern = ";") + 1, 
         N = row_number()) %>% 
  # Create a data frame with one geneid per row
  do(data.frame(.[rep(.$N, .$nmasterids), ], 
                masterid=unlist(strsplit(.$masterids, "; ", fixed=TRUE))))

bootstrap.geneid <- left_join(bootstrap.masterid, uniprot.ids.sequences[, c(1:2)], by = "masterid")
bootstrap.geneid <- bootstrap.geneid[, c(1:3, 1006:1007, 4:1003)]
bootstrap.geneid <- filter(bootstrap.geneid, geneid!="Uncharacterized")
```

###Data Summarization
1. Calculating hl.ratio by median: for both both psmdata and bootstrap data. Other parameters calculated are: Inter Quartile Range (IQR), Quartile Coefficient of Deviation (QCoD) and peptide count. 
```{r}
psmdata.rep1stats <- psmdata.geneid.static %>%
  filter(rep=="1") %>%
  group_by(geneid) %>% 
  summarize (hl.ratio.rep1 =median(norm.hl.ratio), 
             IQR.rep1 = IQR(norm.hl.ratio, type=7), 
             QCoD.rep1 = IQR.rep1/hl.ratio.rep1, 
             count.rep1 = n())

psmdata.rep2stats <- psmdata.geneid.static %>% 
  filter(rep=="2") %>%
  group_by(geneid) %>% 
  summarize (hl.ratio.rep2 = median(norm.hl.ratio), 
             IQR.rep2 = IQR(norm.hl.ratio, type=7), 
             QCoD.rep2 = IQR.rep2/hl.ratio.rep2, 
             count.rep2 = n())

psmdata.rep3stats <- psmdata.geneid.static %>%
  filter(rep=="3") %>%
  group_by(geneid) %>% 
  summarize (hl.ratio.rep3 =median(norm.hl.ratio), 
             IQR.rep3 = IQR(norm.hl.ratio, type=7), 
             QCoD.rep3 = IQR.rep3/hl.ratio.rep3, 
             count.rep3 = n())

psmdata.rep4stats <- psmdata.geneid.static %>% 
  filter(rep=="4") %>%
  group_by(geneid) %>% 
  summarize (hl.ratio.rep4 = median(norm.hl.ratio), 
             IQR.rep4 = IQR(norm.hl.ratio, type=7), 
             QCoD.rep4 = IQR.rep4/hl.ratio.rep4, 
             count.rep4 = n())

psmdata.repstats <- psmdata.geneid.static %>% 
    filter(rep!= "1", rep!= "2") %>%
  group_by(geneid) %>% 
  summarize (hl.ratio=median(norm.hl.ratio), 
             area = median(area),
             protein.length = mean(protein.length), 
             rep=mean(as.numeric(rep)), 
             IQR = IQR(norm.hl.ratio, type=7), 
             QCoD = IQR/hl.ratio, 
             count = n())

psmdata.summary.static <- full_join(psmdata.rep1stats, psmdata.rep2stats, by="geneid")
psmdata.summary.static <- full_join(psmdata.summary.static, psmdata.rep3stats, by="geneid")
psmdata.summary.static <- full_join(psmdata.summary.static, psmdata.rep4stats, by="geneid")
psmdata.summary.static <- full_join(psmdata.summary.static, psmdata.repstats, by="geneid")

#bootstrap
bootstrap.summary <- bootstrap.geneid[, c(5:1005)] %>%
  group_by(geneid) %>% 
  summarise_all (funs(median))

bootstrap.summary.formeanandsd <- bootstrap.summary[, c(2:1001)]

bootstrap.mean.sd <- data.frame(cbind(mean = rowMeans(bootstrap.summary.formeanandsd), sd=apply(bootstrap.summary.formeanandsd,1, sd, na.rm = TRUE)))

bootstrap.mean.sd <- cbind(bootstrap.summary$geneid, bootstrap.mean.sd)

names(bootstrap.mean.sd) <- c("geneid", "mean", "sd")
```

2. Estimate p.value by using the bootstrap distribution of protein hl.ratios (Note: Should I correct for multiple hypothesis even with bootstrap? It does not seem necessary to me, but I need to check and make sure I am not mistaken)  
```{r}
psmdata.summary.pval.static <- full_join(psmdata.summary.static, bootstrap.mean.sd, by = "geneid")
psmdata.summary.pval.static <- psmdata.summary.pval.static %>% 
                          mutate(zscore = (hl.ratio-mean)/sd) 

pval <- 2*pnorm(-(abs(psmdata.summary.pval.static$zscore)))
psmdata.summary.pval.static <- cbind(psmdata.summary.pval.static, pval)

# psmdata.summary <- cbind(psmdata.summary, 
#                                p.value = 2*pnorm(-(abs(psmdata.summary$hl.ratio))))
# 
# nrow(psmdata.summary)
# #5240
# psmdata.summary <- cbind(psmdata.summary, 
#                                adjusted.p.value = p.adjust(
#                                  psmdata.summary$p.value, 
#                                  method="hochberg", 
#                                  n = 5245))
```  

3. Importing RNA-seq data from MB135 with vDUX4 and iDUX4 (already saved as an R object) - from the HMG paper analysis
```{r}
load("~/Dropbox/Manuscripts/DUX4_proteomics/data/rdata/edgeR_foldchange_unfiltered.Rdata")
rnaseq.unfiltered <- foldchange.unfiltered[, c(2:7, 13:17)]
names(rnaseq.unfiltered) <- c("geneid", "iDUX4_logFC_UF", "iDUX4_logCPM_UF", "iDUX4_LR_UF", "iDUX4_pval_UF", "iDUX4_fdr_UF", "vDUX4_logFC_UF", "vDUX4_logCPM_UF", "vDUX4_LR_UF", "vDUX4_pval_UF", "vDUX4_fdr_UF")

library(readr)
rnaseq.filtered <- read_delim("~/Dropbox/Manuscripts/DUX4_proteomics/data/rnaseq.filtered.txt", "\t", escape_double = FALSE, trim_ws = TRUE)
rnaseq.filtered <- rnaseq.filtered[, c(2:7, 13:17)]

names(rnaseq.filtered) <- c("geneid", "iDUX4_logFC", "iDUX4_logCPM", "iDUX4_LR", "iDUX4_pval", "iDUX4_fdr", "vDUX4_logFC", "vDUX4_logCPM", "vDUX4_LR", "vDUX4_pval", "vDUX4_fdr")

rnaseq <- full_join(rnaseq.filtered, rnaseq.unfiltered, by = "geneid")


``` 

4. Merging RNA-seq data with SILAC data using full_join
```{r}
data.rnaseq.silac.static <- full_join(rnaseq, psmdata.summary.pval.static, by = "geneid")
#names(data.rnaseq.ss_silac.static) <- c("geneid", "geneDescription", "RNAseq.8h", "BayesFactor.8h", "RNAseq.14h", "BayesFactor.14h", "hl.ratio.rep1", "IQR.rep1", "QCoD.rep1", "count.rep1", "hl.ratio.rep2", "IQR.rep2", "QCoD.rep2", "count.rep2", "hl.ratio", "area", "protein.length", "rep", "IQR", "QCoD", "count", "mean", "sd", "zscore", "pval")
```
Final number of protein ids: `r nrow(data.rnaseq.silac.static)`

5. (Optional) Exporting data
```{r}
#save(data.rnaseq.silac.static, file="data/Rdata/data.rnaseq.silac.static_021018.Rdata")
#write.csv(data.rnaseq.silac.static, file="data/Rdata/data.rnaseq.silac.static_021018.csv")

save(data.rnaseq.silac.static, file="data/Rdata/data.rnaseq.silac.static_06072018.Rdata")
write.csv(data.rnaseq.silac.static, file="data/Rdata/data.rnaseq.silac.static_06072018.csv")

```  

